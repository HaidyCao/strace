/* Generated by ./gen_bpf_attr_check.sh from bpf_attr.h; do not edit. */
#include "defs.h"
#ifdef HAVE_LINUX_BPF_H
# include <linux/bpf.h>
# include "bpf_attr.h"
# include "static_assert.h"

# define SoM(type_, member_) (sizeof(((type_ *)0)->member_))

# ifdef HAVE_UNION_BPF_ATTR_MAP_TYPE
	static_assert(SoM(struct BPF_MAP_CREATE_struct, map_type) == SoM(union bpf_attr, map_type),
		      "BPF_MAP_CREATE_struct.map_type size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, map_type) == offsetof(union bpf_attr, map_type),
		      "BPF_MAP_CREATE_struct.map_type offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_TYPE */

# ifdef HAVE_UNION_BPF_ATTR_KEY_SIZE
	static_assert(SoM(struct BPF_MAP_CREATE_struct, key_size) == SoM(union bpf_attr, key_size),
		      "BPF_MAP_CREATE_struct.key_size size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, key_size) == offsetof(union bpf_attr, key_size),
		      "BPF_MAP_CREATE_struct.key_size offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_KEY_SIZE */

# ifdef HAVE_UNION_BPF_ATTR_VALUE_SIZE
	static_assert(SoM(struct BPF_MAP_CREATE_struct, value_size) == SoM(union bpf_attr, value_size),
		      "BPF_MAP_CREATE_struct.value_size size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, value_size) == offsetof(union bpf_attr, value_size),
		      "BPF_MAP_CREATE_struct.value_size offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_VALUE_SIZE */

# ifdef HAVE_UNION_BPF_ATTR_MAX_ENTRIES
	static_assert(SoM(struct BPF_MAP_CREATE_struct, max_entries) == SoM(union bpf_attr, max_entries),
		      "BPF_MAP_CREATE_struct.max_entries size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, max_entries) == offsetof(union bpf_attr, max_entries),
		      "BPF_MAP_CREATE_struct.max_entries offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAX_ENTRIES */

# ifdef HAVE_UNION_BPF_ATTR_MAP_FLAGS
	static_assert(SoM(struct BPF_MAP_CREATE_struct, map_flags) == SoM(union bpf_attr, map_flags),
		      "BPF_MAP_CREATE_struct.map_flags size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, map_flags) == offsetof(union bpf_attr, map_flags),
		      "BPF_MAP_CREATE_struct.map_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_FLAGS */

# ifdef HAVE_UNION_BPF_ATTR_INNER_MAP_FD
	static_assert(SoM(struct BPF_MAP_CREATE_struct, inner_map_fd) == SoM(union bpf_attr, inner_map_fd),
		      "BPF_MAP_CREATE_struct.inner_map_fd size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, inner_map_fd) == offsetof(union bpf_attr, inner_map_fd),
		      "BPF_MAP_CREATE_struct.inner_map_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_INNER_MAP_FD */

# ifdef HAVE_UNION_BPF_ATTR_NUMA_NODE
	static_assert(SoM(struct BPF_MAP_CREATE_struct, numa_node) == SoM(union bpf_attr, numa_node),
		      "BPF_MAP_CREATE_struct.numa_node size mismatch");
	static_assert(offsetof(struct BPF_MAP_CREATE_struct, numa_node) == offsetof(union bpf_attr, numa_node),
		      "BPF_MAP_CREATE_struct.numa_node offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_NUMA_NODE */

static_assert(BPF_MAP_CREATE_struct_size == expected_BPF_MAP_CREATE_struct_size,
	      "BPF_MAP_CREATE_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_MAP_FD
	static_assert(SoM(struct BPF_MAP_LOOKUP_ELEM_struct, map_fd) == SoM(union bpf_attr, map_fd),
		      "BPF_MAP_LOOKUP_ELEM_struct.map_fd size mismatch");
	static_assert(offsetof(struct BPF_MAP_LOOKUP_ELEM_struct, map_fd) == offsetof(union bpf_attr, map_fd),
		      "BPF_MAP_LOOKUP_ELEM_struct.map_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_FD */

# ifdef HAVE_UNION_BPF_ATTR_KEY
	static_assert(SoM(struct BPF_MAP_LOOKUP_ELEM_struct, key) == SoM(union bpf_attr, key),
		      "BPF_MAP_LOOKUP_ELEM_struct.key size mismatch");
	static_assert(offsetof(struct BPF_MAP_LOOKUP_ELEM_struct, key) == offsetof(union bpf_attr, key),
		      "BPF_MAP_LOOKUP_ELEM_struct.key offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_KEY */

# ifdef HAVE_UNION_BPF_ATTR_VALUE
	static_assert(SoM(struct BPF_MAP_LOOKUP_ELEM_struct, value) == SoM(union bpf_attr, value),
		      "BPF_MAP_LOOKUP_ELEM_struct.value size mismatch");
	static_assert(offsetof(struct BPF_MAP_LOOKUP_ELEM_struct, value) == offsetof(union bpf_attr, value),
		      "BPF_MAP_LOOKUP_ELEM_struct.value offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_VALUE */

static_assert(BPF_MAP_LOOKUP_ELEM_struct_size == expected_BPF_MAP_LOOKUP_ELEM_struct_size,
	      "BPF_MAP_LOOKUP_ELEM_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_MAP_FD
	static_assert(SoM(struct BPF_MAP_UPDATE_ELEM_struct, map_fd) == SoM(union bpf_attr, map_fd),
		      "BPF_MAP_UPDATE_ELEM_struct.map_fd size mismatch");
	static_assert(offsetof(struct BPF_MAP_UPDATE_ELEM_struct, map_fd) == offsetof(union bpf_attr, map_fd),
		      "BPF_MAP_UPDATE_ELEM_struct.map_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_FD */

# ifdef HAVE_UNION_BPF_ATTR_KEY
	static_assert(SoM(struct BPF_MAP_UPDATE_ELEM_struct, key) == SoM(union bpf_attr, key),
		      "BPF_MAP_UPDATE_ELEM_struct.key size mismatch");
	static_assert(offsetof(struct BPF_MAP_UPDATE_ELEM_struct, key) == offsetof(union bpf_attr, key),
		      "BPF_MAP_UPDATE_ELEM_struct.key offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_KEY */

# ifdef HAVE_UNION_BPF_ATTR_VALUE
	static_assert(SoM(struct BPF_MAP_UPDATE_ELEM_struct, value) == SoM(union bpf_attr, value),
		      "BPF_MAP_UPDATE_ELEM_struct.value size mismatch");
	static_assert(offsetof(struct BPF_MAP_UPDATE_ELEM_struct, value) == offsetof(union bpf_attr, value),
		      "BPF_MAP_UPDATE_ELEM_struct.value offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_VALUE */

# ifdef HAVE_UNION_BPF_ATTR_FLAGS
	static_assert(SoM(struct BPF_MAP_UPDATE_ELEM_struct, flags) == SoM(union bpf_attr, flags),
		      "BPF_MAP_UPDATE_ELEM_struct.flags size mismatch");
	static_assert(offsetof(struct BPF_MAP_UPDATE_ELEM_struct, flags) == offsetof(union bpf_attr, flags),
		      "BPF_MAP_UPDATE_ELEM_struct.flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_FLAGS */

static_assert(BPF_MAP_UPDATE_ELEM_struct_size == expected_BPF_MAP_UPDATE_ELEM_struct_size,
	      "BPF_MAP_UPDATE_ELEM_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_MAP_FD
	static_assert(SoM(struct BPF_MAP_DELETE_ELEM_struct, map_fd) == SoM(union bpf_attr, map_fd),
		      "BPF_MAP_DELETE_ELEM_struct.map_fd size mismatch");
	static_assert(offsetof(struct BPF_MAP_DELETE_ELEM_struct, map_fd) == offsetof(union bpf_attr, map_fd),
		      "BPF_MAP_DELETE_ELEM_struct.map_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_FD */

# ifdef HAVE_UNION_BPF_ATTR_KEY
	static_assert(SoM(struct BPF_MAP_DELETE_ELEM_struct, key) == SoM(union bpf_attr, key),
		      "BPF_MAP_DELETE_ELEM_struct.key size mismatch");
	static_assert(offsetof(struct BPF_MAP_DELETE_ELEM_struct, key) == offsetof(union bpf_attr, key),
		      "BPF_MAP_DELETE_ELEM_struct.key offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_KEY */

static_assert(BPF_MAP_DELETE_ELEM_struct_size == expected_BPF_MAP_DELETE_ELEM_struct_size,
	      "BPF_MAP_DELETE_ELEM_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_MAP_FD
	static_assert(SoM(struct BPF_MAP_GET_NEXT_KEY_struct, map_fd) == SoM(union bpf_attr, map_fd),
		      "BPF_MAP_GET_NEXT_KEY_struct.map_fd size mismatch");
	static_assert(offsetof(struct BPF_MAP_GET_NEXT_KEY_struct, map_fd) == offsetof(union bpf_attr, map_fd),
		      "BPF_MAP_GET_NEXT_KEY_struct.map_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_FD */

# ifdef HAVE_UNION_BPF_ATTR_KEY
	static_assert(SoM(struct BPF_MAP_GET_NEXT_KEY_struct, key) == SoM(union bpf_attr, key),
		      "BPF_MAP_GET_NEXT_KEY_struct.key size mismatch");
	static_assert(offsetof(struct BPF_MAP_GET_NEXT_KEY_struct, key) == offsetof(union bpf_attr, key),
		      "BPF_MAP_GET_NEXT_KEY_struct.key offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_KEY */

# ifdef HAVE_UNION_BPF_ATTR_NEXT_KEY
	static_assert(SoM(struct BPF_MAP_GET_NEXT_KEY_struct, next_key) == SoM(union bpf_attr, next_key),
		      "BPF_MAP_GET_NEXT_KEY_struct.next_key size mismatch");
	static_assert(offsetof(struct BPF_MAP_GET_NEXT_KEY_struct, next_key) == offsetof(union bpf_attr, next_key),
		      "BPF_MAP_GET_NEXT_KEY_struct.next_key offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_NEXT_KEY */

static_assert(BPF_MAP_GET_NEXT_KEY_struct_size == expected_BPF_MAP_GET_NEXT_KEY_struct_size,
	      "BPF_MAP_GET_NEXT_KEY_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_PROG_TYPE
	static_assert(SoM(struct BPF_PROG_LOAD_struct, prog_type) == SoM(union bpf_attr, prog_type),
		      "BPF_PROG_LOAD_struct.prog_type size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, prog_type) == offsetof(union bpf_attr, prog_type),
		      "BPF_PROG_LOAD_struct.prog_type offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_PROG_TYPE */

# ifdef HAVE_UNION_BPF_ATTR_INSN_CNT
	static_assert(SoM(struct BPF_PROG_LOAD_struct, insn_cnt) == SoM(union bpf_attr, insn_cnt),
		      "BPF_PROG_LOAD_struct.insn_cnt size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, insn_cnt) == offsetof(union bpf_attr, insn_cnt),
		      "BPF_PROG_LOAD_struct.insn_cnt offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_INSN_CNT */

# ifdef HAVE_UNION_BPF_ATTR_INSNS
	static_assert(SoM(struct BPF_PROG_LOAD_struct, insns) == SoM(union bpf_attr, insns),
		      "BPF_PROG_LOAD_struct.insns size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, insns) == offsetof(union bpf_attr, insns),
		      "BPF_PROG_LOAD_struct.insns offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_INSNS */

# ifdef HAVE_UNION_BPF_ATTR_LICENSE
	static_assert(SoM(struct BPF_PROG_LOAD_struct, license) == SoM(union bpf_attr, license),
		      "BPF_PROG_LOAD_struct.license size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, license) == offsetof(union bpf_attr, license),
		      "BPF_PROG_LOAD_struct.license offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_LICENSE */

# ifdef HAVE_UNION_BPF_ATTR_LOG_LEVEL
	static_assert(SoM(struct BPF_PROG_LOAD_struct, log_level) == SoM(union bpf_attr, log_level),
		      "BPF_PROG_LOAD_struct.log_level size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, log_level) == offsetof(union bpf_attr, log_level),
		      "BPF_PROG_LOAD_struct.log_level offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_LOG_LEVEL */

# ifdef HAVE_UNION_BPF_ATTR_LOG_SIZE
	static_assert(SoM(struct BPF_PROG_LOAD_struct, log_size) == SoM(union bpf_attr, log_size),
		      "BPF_PROG_LOAD_struct.log_size size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, log_size) == offsetof(union bpf_attr, log_size),
		      "BPF_PROG_LOAD_struct.log_size offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_LOG_SIZE */

# ifdef HAVE_UNION_BPF_ATTR_LOG_BUF
	static_assert(SoM(struct BPF_PROG_LOAD_struct, log_buf) == SoM(union bpf_attr, log_buf),
		      "BPF_PROG_LOAD_struct.log_buf size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, log_buf) == offsetof(union bpf_attr, log_buf),
		      "BPF_PROG_LOAD_struct.log_buf offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_LOG_BUF */

# ifdef HAVE_UNION_BPF_ATTR_KERN_VERSION
	static_assert(SoM(struct BPF_PROG_LOAD_struct, kern_version) == SoM(union bpf_attr, kern_version),
		      "BPF_PROG_LOAD_struct.kern_version size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, kern_version) == offsetof(union bpf_attr, kern_version),
		      "BPF_PROG_LOAD_struct.kern_version offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_KERN_VERSION */

# ifdef HAVE_UNION_BPF_ATTR_PROG_FLAGS
	static_assert(SoM(struct BPF_PROG_LOAD_struct, prog_flags) == SoM(union bpf_attr, prog_flags),
		      "BPF_PROG_LOAD_struct.prog_flags size mismatch");
	static_assert(offsetof(struct BPF_PROG_LOAD_struct, prog_flags) == offsetof(union bpf_attr, prog_flags),
		      "BPF_PROG_LOAD_struct.prog_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_PROG_FLAGS */

static_assert(BPF_PROG_LOAD_struct_size == expected_BPF_PROG_LOAD_struct_size,
	      "BPF_PROG_LOAD_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_PATHNAME
	static_assert(SoM(struct BPF_OBJ_PIN_struct, pathname) == SoM(union bpf_attr, pathname),
		      "BPF_OBJ_PIN_struct.pathname size mismatch");
	static_assert(offsetof(struct BPF_OBJ_PIN_struct, pathname) == offsetof(union bpf_attr, pathname),
		      "BPF_OBJ_PIN_struct.pathname offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_PATHNAME */

# ifdef HAVE_UNION_BPF_ATTR_BPF_FD
	static_assert(SoM(struct BPF_OBJ_PIN_struct, bpf_fd) == SoM(union bpf_attr, bpf_fd),
		      "BPF_OBJ_PIN_struct.bpf_fd size mismatch");
	static_assert(offsetof(struct BPF_OBJ_PIN_struct, bpf_fd) == offsetof(union bpf_attr, bpf_fd),
		      "BPF_OBJ_PIN_struct.bpf_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_BPF_FD */

# ifdef HAVE_UNION_BPF_ATTR_FILE_FLAGS
	static_assert(SoM(struct BPF_OBJ_PIN_struct, file_flags) == SoM(union bpf_attr, file_flags),
		      "BPF_OBJ_PIN_struct.file_flags size mismatch");
	static_assert(offsetof(struct BPF_OBJ_PIN_struct, file_flags) == offsetof(union bpf_attr, file_flags),
		      "BPF_OBJ_PIN_struct.file_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_FILE_FLAGS */

static_assert(BPF_OBJ_PIN_struct_size == expected_BPF_OBJ_PIN_struct_size,
	      "BPF_OBJ_PIN_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_TARGET_FD
	static_assert(SoM(struct BPF_PROG_ATTACH_struct, target_fd) == SoM(union bpf_attr, target_fd),
		      "BPF_PROG_ATTACH_struct.target_fd size mismatch");
	static_assert(offsetof(struct BPF_PROG_ATTACH_struct, target_fd) == offsetof(union bpf_attr, target_fd),
		      "BPF_PROG_ATTACH_struct.target_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TARGET_FD */

# ifdef HAVE_UNION_BPF_ATTR_ATTACH_BPF_FD
	static_assert(SoM(struct BPF_PROG_ATTACH_struct, attach_bpf_fd) == SoM(union bpf_attr, attach_bpf_fd),
		      "BPF_PROG_ATTACH_struct.attach_bpf_fd size mismatch");
	static_assert(offsetof(struct BPF_PROG_ATTACH_struct, attach_bpf_fd) == offsetof(union bpf_attr, attach_bpf_fd),
		      "BPF_PROG_ATTACH_struct.attach_bpf_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_ATTACH_BPF_FD */

# ifdef HAVE_UNION_BPF_ATTR_ATTACH_TYPE
	static_assert(SoM(struct BPF_PROG_ATTACH_struct, attach_type) == SoM(union bpf_attr, attach_type),
		      "BPF_PROG_ATTACH_struct.attach_type size mismatch");
	static_assert(offsetof(struct BPF_PROG_ATTACH_struct, attach_type) == offsetof(union bpf_attr, attach_type),
		      "BPF_PROG_ATTACH_struct.attach_type offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_ATTACH_TYPE */

# ifdef HAVE_UNION_BPF_ATTR_ATTACH_FLAGS
	static_assert(SoM(struct BPF_PROG_ATTACH_struct, attach_flags) == SoM(union bpf_attr, attach_flags),
		      "BPF_PROG_ATTACH_struct.attach_flags size mismatch");
	static_assert(offsetof(struct BPF_PROG_ATTACH_struct, attach_flags) == offsetof(union bpf_attr, attach_flags),
		      "BPF_PROG_ATTACH_struct.attach_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_ATTACH_FLAGS */

static_assert(BPF_PROG_ATTACH_struct_size == expected_BPF_PROG_ATTACH_struct_size,
	      "BPF_PROG_ATTACH_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_TARGET_FD
	static_assert(SoM(struct BPF_PROG_DETACH_struct, target_fd) == SoM(union bpf_attr, target_fd),
		      "BPF_PROG_DETACH_struct.target_fd size mismatch");
	static_assert(offsetof(struct BPF_PROG_DETACH_struct, target_fd) == offsetof(union bpf_attr, target_fd),
		      "BPF_PROG_DETACH_struct.target_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TARGET_FD */

# ifdef HAVE_UNION_BPF_ATTR_DUMMY
	static_assert(SoM(struct BPF_PROG_DETACH_struct, dummy) == SoM(union bpf_attr, dummy),
		      "BPF_PROG_DETACH_struct.dummy size mismatch");
	static_assert(offsetof(struct BPF_PROG_DETACH_struct, dummy) == offsetof(union bpf_attr, dummy),
		      "BPF_PROG_DETACH_struct.dummy offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_DUMMY */

# ifdef HAVE_UNION_BPF_ATTR_ATTACH_TYPE
	static_assert(SoM(struct BPF_PROG_DETACH_struct, attach_type) == SoM(union bpf_attr, attach_type),
		      "BPF_PROG_DETACH_struct.attach_type size mismatch");
	static_assert(offsetof(struct BPF_PROG_DETACH_struct, attach_type) == offsetof(union bpf_attr, attach_type),
		      "BPF_PROG_DETACH_struct.attach_type offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_ATTACH_TYPE */

static_assert(BPF_PROG_DETACH_struct_size == expected_BPF_PROG_DETACH_struct_size,
	      "BPF_PROG_DETACH_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_TEST_PROG_FD
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, prog_fd) == SoM(union bpf_attr, test.prog_fd),
		      "BPF_PROG_TEST_RUN_struct.prog_fd size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, prog_fd) == offsetof(union bpf_attr, test.prog_fd),
		      "BPF_PROG_TEST_RUN_struct.prog_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_PROG_FD */

# ifdef HAVE_UNION_BPF_ATTR_TEST_RETVAL
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, retval) == SoM(union bpf_attr, test.retval),
		      "BPF_PROG_TEST_RUN_struct.retval size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, retval) == offsetof(union bpf_attr, test.retval),
		      "BPF_PROG_TEST_RUN_struct.retval offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_RETVAL */

# ifdef HAVE_UNION_BPF_ATTR_TEST_DATA_SIZE_IN
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, data_size_in) == SoM(union bpf_attr, test.data_size_in),
		      "BPF_PROG_TEST_RUN_struct.data_size_in size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, data_size_in) == offsetof(union bpf_attr, test.data_size_in),
		      "BPF_PROG_TEST_RUN_struct.data_size_in offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_DATA_SIZE_IN */

# ifdef HAVE_UNION_BPF_ATTR_TEST_DATA_SIZE_OUT
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, data_size_out) == SoM(union bpf_attr, test.data_size_out),
		      "BPF_PROG_TEST_RUN_struct.data_size_out size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, data_size_out) == offsetof(union bpf_attr, test.data_size_out),
		      "BPF_PROG_TEST_RUN_struct.data_size_out offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_DATA_SIZE_OUT */

# ifdef HAVE_UNION_BPF_ATTR_TEST_DATA_IN
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, data_in) == SoM(union bpf_attr, test.data_in),
		      "BPF_PROG_TEST_RUN_struct.data_in size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, data_in) == offsetof(union bpf_attr, test.data_in),
		      "BPF_PROG_TEST_RUN_struct.data_in offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_DATA_IN */

# ifdef HAVE_UNION_BPF_ATTR_TEST_DATA_OUT
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, data_out) == SoM(union bpf_attr, test.data_out),
		      "BPF_PROG_TEST_RUN_struct.data_out size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, data_out) == offsetof(union bpf_attr, test.data_out),
		      "BPF_PROG_TEST_RUN_struct.data_out offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_DATA_OUT */

# ifdef HAVE_UNION_BPF_ATTR_TEST_REPEAT
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, repeat) == SoM(union bpf_attr, test.repeat),
		      "BPF_PROG_TEST_RUN_struct.repeat size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, repeat) == offsetof(union bpf_attr, test.repeat),
		      "BPF_PROG_TEST_RUN_struct.repeat offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_REPEAT */

# ifdef HAVE_UNION_BPF_ATTR_TEST_DURATION
	static_assert(SoM(struct BPF_PROG_TEST_RUN_struct, duration) == SoM(union bpf_attr, test.duration),
		      "BPF_PROG_TEST_RUN_struct.duration size mismatch");
	static_assert(offsetof(struct BPF_PROG_TEST_RUN_struct, duration) == offsetof(union bpf_attr, test.duration),
		      "BPF_PROG_TEST_RUN_struct.duration offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_TEST_DURATION */

static_assert(BPF_PROG_TEST_RUN_struct_size == expected_BPF_PROG_TEST_RUN_struct_size,
	      "BPF_PROG_TEST_RUN_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_START_ID
	static_assert(SoM(struct BPF_PROG_GET_NEXT_ID_struct, start_id) == SoM(union bpf_attr, start_id),
		      "BPF_PROG_GET_NEXT_ID_struct.start_id size mismatch");
	static_assert(offsetof(struct BPF_PROG_GET_NEXT_ID_struct, start_id) == offsetof(union bpf_attr, start_id),
		      "BPF_PROG_GET_NEXT_ID_struct.start_id offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_START_ID */

# ifdef HAVE_UNION_BPF_ATTR_NEXT_ID
	static_assert(SoM(struct BPF_PROG_GET_NEXT_ID_struct, next_id) == SoM(union bpf_attr, next_id),
		      "BPF_PROG_GET_NEXT_ID_struct.next_id size mismatch");
	static_assert(offsetof(struct BPF_PROG_GET_NEXT_ID_struct, next_id) == offsetof(union bpf_attr, next_id),
		      "BPF_PROG_GET_NEXT_ID_struct.next_id offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_NEXT_ID */

# ifdef HAVE_UNION_BPF_ATTR_OPEN_FLAGS
	static_assert(SoM(struct BPF_PROG_GET_NEXT_ID_struct, open_flags) == SoM(union bpf_attr, open_flags),
		      "BPF_PROG_GET_NEXT_ID_struct.open_flags size mismatch");
	static_assert(offsetof(struct BPF_PROG_GET_NEXT_ID_struct, open_flags) == offsetof(union bpf_attr, open_flags),
		      "BPF_PROG_GET_NEXT_ID_struct.open_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_OPEN_FLAGS */

static_assert(BPF_PROG_GET_NEXT_ID_struct_size == expected_BPF_PROG_GET_NEXT_ID_struct_size,
	      "BPF_PROG_GET_NEXT_ID_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_PROG_ID
	static_assert(SoM(struct BPF_PROG_GET_FD_BY_ID_struct, prog_id) == SoM(union bpf_attr, prog_id),
		      "BPF_PROG_GET_FD_BY_ID_struct.prog_id size mismatch");
	static_assert(offsetof(struct BPF_PROG_GET_FD_BY_ID_struct, prog_id) == offsetof(union bpf_attr, prog_id),
		      "BPF_PROG_GET_FD_BY_ID_struct.prog_id offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_PROG_ID */

# ifdef HAVE_UNION_BPF_ATTR_NEXT_ID
	static_assert(SoM(struct BPF_PROG_GET_FD_BY_ID_struct, next_id) == SoM(union bpf_attr, next_id),
		      "BPF_PROG_GET_FD_BY_ID_struct.next_id size mismatch");
	static_assert(offsetof(struct BPF_PROG_GET_FD_BY_ID_struct, next_id) == offsetof(union bpf_attr, next_id),
		      "BPF_PROG_GET_FD_BY_ID_struct.next_id offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_NEXT_ID */

# ifdef HAVE_UNION_BPF_ATTR_OPEN_FLAGS
	static_assert(SoM(struct BPF_PROG_GET_FD_BY_ID_struct, open_flags) == SoM(union bpf_attr, open_flags),
		      "BPF_PROG_GET_FD_BY_ID_struct.open_flags size mismatch");
	static_assert(offsetof(struct BPF_PROG_GET_FD_BY_ID_struct, open_flags) == offsetof(union bpf_attr, open_flags),
		      "BPF_PROG_GET_FD_BY_ID_struct.open_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_OPEN_FLAGS */

static_assert(BPF_PROG_GET_FD_BY_ID_struct_size == expected_BPF_PROG_GET_FD_BY_ID_struct_size,
	      "BPF_PROG_GET_FD_BY_ID_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_MAP_ID
	static_assert(SoM(struct BPF_MAP_GET_FD_BY_ID_struct, map_id) == SoM(union bpf_attr, map_id),
		      "BPF_MAP_GET_FD_BY_ID_struct.map_id size mismatch");
	static_assert(offsetof(struct BPF_MAP_GET_FD_BY_ID_struct, map_id) == offsetof(union bpf_attr, map_id),
		      "BPF_MAP_GET_FD_BY_ID_struct.map_id offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_MAP_ID */

# ifdef HAVE_UNION_BPF_ATTR_NEXT_ID
	static_assert(SoM(struct BPF_MAP_GET_FD_BY_ID_struct, next_id) == SoM(union bpf_attr, next_id),
		      "BPF_MAP_GET_FD_BY_ID_struct.next_id size mismatch");
	static_assert(offsetof(struct BPF_MAP_GET_FD_BY_ID_struct, next_id) == offsetof(union bpf_attr, next_id),
		      "BPF_MAP_GET_FD_BY_ID_struct.next_id offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_NEXT_ID */

# ifdef HAVE_UNION_BPF_ATTR_OPEN_FLAGS
	static_assert(SoM(struct BPF_MAP_GET_FD_BY_ID_struct, open_flags) == SoM(union bpf_attr, open_flags),
		      "BPF_MAP_GET_FD_BY_ID_struct.open_flags size mismatch");
	static_assert(offsetof(struct BPF_MAP_GET_FD_BY_ID_struct, open_flags) == offsetof(union bpf_attr, open_flags),
		      "BPF_MAP_GET_FD_BY_ID_struct.open_flags offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_OPEN_FLAGS */

static_assert(BPF_MAP_GET_FD_BY_ID_struct_size == expected_BPF_MAP_GET_FD_BY_ID_struct_size,
	      "BPF_MAP_GET_FD_BY_ID_struct_size mismatch");

# ifdef HAVE_UNION_BPF_ATTR_INFO_BPF_FD
	static_assert(SoM(struct BPF_OBJ_GET_INFO_BY_FD_struct, bpf_fd) == SoM(union bpf_attr, info.bpf_fd),
		      "BPF_OBJ_GET_INFO_BY_FD_struct.bpf_fd size mismatch");
	static_assert(offsetof(struct BPF_OBJ_GET_INFO_BY_FD_struct, bpf_fd) == offsetof(union bpf_attr, info.bpf_fd),
		      "BPF_OBJ_GET_INFO_BY_FD_struct.bpf_fd offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_INFO_BPF_FD */

# ifdef HAVE_UNION_BPF_ATTR_INFO_INFO_LEN
	static_assert(SoM(struct BPF_OBJ_GET_INFO_BY_FD_struct, info_len) == SoM(union bpf_attr, info.info_len),
		      "BPF_OBJ_GET_INFO_BY_FD_struct.info_len size mismatch");
	static_assert(offsetof(struct BPF_OBJ_GET_INFO_BY_FD_struct, info_len) == offsetof(union bpf_attr, info.info_len),
		      "BPF_OBJ_GET_INFO_BY_FD_struct.info_len offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_INFO_INFO_LEN */

# ifdef HAVE_UNION_BPF_ATTR_INFO_INFO
	static_assert(SoM(struct BPF_OBJ_GET_INFO_BY_FD_struct, info) == SoM(union bpf_attr, info.info),
		      "BPF_OBJ_GET_INFO_BY_FD_struct.info size mismatch");
	static_assert(offsetof(struct BPF_OBJ_GET_INFO_BY_FD_struct, info) == offsetof(union bpf_attr, info.info),
		      "BPF_OBJ_GET_INFO_BY_FD_struct.info offset mismatch");
# endif /* HAVE_UNION_BPF_ATTR_INFO_INFO */

static_assert(BPF_OBJ_GET_INFO_BY_FD_struct_size == expected_BPF_OBJ_GET_INFO_BY_FD_struct_size,
	      "BPF_OBJ_GET_INFO_BY_FD_struct_size mismatch");

#endif /* HAVE_LINUX_BPF_H */
